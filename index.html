<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BFDIA 5b</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <!-- Load local Ruffle build placed next to this HTML (ruffle.js) -->
  <script src="ruffle.js"></script>
  <style>
    /* Make the page and ruffle player fill the entire viewport */
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
    }

    /* Full-viewport fixed container so the player always fills the page */
    #game {
      position: fixed;
      inset: 0; /* top:0; right:0; bottom:0; left:0; */
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    /* Ensure the ruffle player and its inner canvas expand to fill the container.
       This sets the player to cover the full viewport. If you prefer letterboxing
       to preserve the original SWF aspect ratio, change these rules to use
       `max-width` / `max-height` and `width: auto; height: auto;` instead. */
    #game ruffle-player,
    #game object,
    #game embed,
    #game canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Container for the SWF -->
  <div id="game"></div>

  <!-- Mobile controls (always visible) - updated layout matching screenshot -->
  <div id="mobile-controls" aria-hidden="false">
    <!-- Left D-Pad: up above, left and right below -->
    <div class="controls-left">
      <div class="dpad" role="group" aria-label="D-Pad">
        <button class="btn d-up" aria-hidden="true" style="visibility:hidden;">▲</button>

        <button class="btn d-left" data-key="ArrowLeft" data-keycode="37" aria-label="Left">◀</button>
        <button class="btn d-right" data-key="ArrowRight" data-keycode="39" aria-label="Right">▶</button>
      </div>
    </div>

    <!-- Right-side actions: Enter top-right, Z/R bottom-right -->
    <div class="controls-right">
      <button id="enter-btn" class="btn enter-top" data-key="Enter" data-keycode="13" aria-label="Confirm">Enter</button>

      <div class="actions-bottom">
        <button class="btn action large jump" data-key=" " data-keycode="32" aria-label="Jump">▲</button>
        <button class="btn action large" data-key="z" data-keycode="90" aria-label="Swap">Z</button>
        <button class="btn action large" data-key="r" data-keycode="82" aria-label="Reset">R</button>
      </div>
    </div>
  </div>

  <script>
    // Initialize Ruffle from local `ruffle.js` and wire controls/fullscreen.
    function initRuffleAndControls() {
      if (!(window.RufflePlayer && typeof window.RufflePlayer.newest === 'function')) {
        console.error('Ruffle not found. Make sure `ruffle.js` is placed next to this HTML file.');
        return;
      }

      const ruffle = window.RufflePlayer.newest();
      const player = ruffle.createPlayer();
      document.getElementById("game").appendChild(player);

      // Load the SWF file (must be in same folder as HTML)
      player.load("5b.swf");
      if (player && player.style) {
        player.style.width = '100%';
        player.style.height = '100%';
        player.style.display = 'block';
      }

      function toggleFullscreen(elem) {
        const doc = document;
        const isFull = doc.fullscreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;
        if (!isFull) {
          if (elem.requestFullscreen) elem.requestFullscreen();
          else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
          else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        } else {
          if (doc.exitFullscreen) doc.exitFullscreen();
          else if (doc.webkitExitFullscreen) doc.webkitExitFullscreen();
          else if (doc.msExitFullscreen) doc.msExitFullscreen();
        }
      }

      document.addEventListener('keydown', function (e) {
        const isF11 = (e.key === 'F11') || (e.keyCode === 122);
        if (isF11) {
          e.preventDefault();
          const container = document.getElementById('game') || document.documentElement;
          toggleFullscreen(container);
        }
      });

      (function () {
        const controls = document.getElementById('mobile-controls');
        if (!controls) return;

        function sendKey(type, key, keyCode, code) {
          const eventInit = { key: key, code: code || key, keyCode: keyCode, which: keyCode, bubbles: true, cancelable: true };
          let ev;
          try { ev = new KeyboardEvent(type, eventInit); }
          catch (err) { ev = document.createEvent('KeyboardEvent'); ev.initKeyboardEvent(type, true, true, window, key, 0, '', false, ''); }
          if (player && typeof player.dispatchEvent === 'function') player.dispatchEvent(ev);
          window.dispatchEvent(ev);
        }

        function bindButton(btn) {
          const key = btn.getAttribute('data-key');
          const keyCode = parseInt(btn.getAttribute('data-keycode'), 10) || 0;
          const code = btn.getAttribute('data-code') || key;
          function onPress(e) { e.preventDefault(); btn.classList.add('active'); sendKey('keydown', key, keyCode, code); }
          function onRelease(e) { e && e.preventDefault(); btn.classList.remove('active'); sendKey('keyup', key, keyCode, code); }
          btn.addEventListener('touchstart', onPress, {passive:false}); btn.addEventListener('mousedown', onPress);
          btn.addEventListener('touchend', onRelease); btn.addEventListener('touchcancel', onRelease); btn.addEventListener('mouseup', onRelease); btn.addEventListener('mouseleave', onRelease);
        }

        const buttons = controls.querySelectorAll('.btn');
        buttons.forEach(bindButton);
      })();
    }

    // Local script should load synchronously; initialize immediately.
    initRuffleAndControls();
  </script>

  <style>
    /* No offline overlay — using local `ruffle.js` placed next to this HTML */
    /* Responsive mobile controls using clamped sizes so buttons don't grow too large */
    :root {
      --ctrl-gap: clamp(6px, 0.8vmin, 14px);
      --btn-size: clamp(40px, 6vmin, 64px); /* base button */
      --btn-large-mult: 1.35;
      --enter-width: clamp(84px, 16vmin, 160px);
      --enter-height: clamp(44px, 9vmin, 96px);
    }

    #mobile-controls { position: fixed; inset: auto 1rem 1rem 1rem; z-index: 9999; pointer-events: auto; }
    /* Move D-pad up so it does not overlap on-screen level text; use viewport-based offset */
    .controls-left { position: fixed; left: calc(env(safe-area-inset-left, 0px) + 1rem); bottom: calc(env(safe-area-inset-bottom, 0px) + 6vh); }
    .controls-right { position: fixed; right: calc(env(safe-area-inset-right, 0px) + 1rem); top: 1rem; bottom: 1rem; pointer-events: none; }

    /* D-pad arranged with up button above left/right; sizes derived from --btn-size */
    .dpad { display: grid; grid-template-areas: "up up up" "left center right"; grid-template-columns: var(--btn-size) var(--btn-size) var(--btn-size); grid-auto-rows: var(--btn-size); gap: var(--ctrl-gap); align-items: center; }
    .d-up { grid-area: up; }
    .d-left { grid-area: left; }
    .d-center { grid-area: center; }
    .d-right { grid-area: right; }

    /* Base button style uses variables so it scales with viewport */
    .btn { background: #000; color: #fff; border: 2px solid rgba(255,255,255,0.95); border-radius: calc(var(--btn-size) * 0.125); width: var(--btn-size); height: var(--btn-size); font-size: calc(var(--btn-size) * 0.42); display:flex; align-items:center; justify-content:center; box-shadow: 0 4px 10px rgba(0,0,0,0.6); pointer-events: auto; }
    .btn:focus { outline: 2px solid rgba(255,255,255,0.18); }
    .btn.large { width: calc(var(--btn-size) * var(--btn-large-mult)); height: calc(var(--btn-size) * var(--btn-large-mult)); font-size: calc(var(--btn-size) * 0.56); border-radius: calc(var(--btn-size) * 0.14); }
    .enter-top { position: fixed; top: 1rem; right: 1rem; width: var(--enter-width); height: var(--enter-height); font-size: calc(var(--enter-height) * 0.45); border-radius: calc(var(--enter-height) * 0.14); pointer-events: auto; }

    .actions-bottom { position: fixed; right: calc(env(safe-area-inset-right, 0px) + 1rem); bottom: calc(env(safe-area-inset-bottom, 0px) + 6vh); display:flex; gap: var(--ctrl-gap); pointer-events: auto; flex-direction: row-reverse; align-items: flex-end; }

    .btn:active, .btn.active { transform: scale(0.96); background: rgba(255,255,255,0.06); }

    /* Keep the jump button on the far right and nudge Z/R out of its way */
    .actions-bottom .action { transform: translateY(calc(-0.15 * var(--btn-size))); }
    .btn.jump { width: calc(var(--btn-size) * var(--btn-large-mult)); height: calc(var(--btn-size) * var(--btn-large-mult)); font-size: calc(var(--btn-size) * 0.56); border-radius: calc(var(--btn-size) * 0.14); }

    /* Ensure child controls within the right column are clickable despite parent pointer-events:none */
    .controls-right .btn, .controls-right .actions-bottom { pointer-events: auto; }

    /* On very wide/larger screens slightly reduce control size so they don't dominate */
    @media (min-width: 900px) {
      :root { --btn-size: clamp(40px, 4.2vmin, 56px); }
      .enter-top { width: clamp(80px, 9vw, 120px); height: clamp(36px, 5.5vh, 56px); }
    }
  </style>
</body>
</html>
