<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BFDIA 5b</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#000000">
  <!-- Load local Ruffle build placed next to this HTML (ruffle.js) -->
  <script src="ruffle.js"></script>
  <style>
    /* Make the page and ruffle player fill the entire viewport */
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
    }

    /* Full-viewport fixed container so the player always fills the page */
    #game {
      position: fixed;
      inset: 0; /* top:0; right:0; bottom:0; left:0; */
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }

    /* Ensure the ruffle player and its inner canvas expand to fill the container.
       This sets the player to cover the full viewport. If you prefer letterboxing
       to preserve the original SWF aspect ratio, change these rules to use
       `max-width` / `max-height` and `width: auto; height: auto;` instead. */
    #game ruffle-player,
    #game object,
    #game embed,
    #game canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Container for the SWF -->
  <div id="game"></div>

  <!-- Toggle to hide/show mobile controls (always visible, top-left) -->
  <button id="mobile-toggle" aria-pressed="true" aria-label="Toggle mobile controls" title="Toggle mobile controls">✕</button>

  <!-- Mobile controls (always visible) - updated layout matching screenshot -->
  <div id="mobile-controls" aria-hidden="false">
    <!-- Left D-Pad: up above, left and right below -->
    <div class="controls-left">
      <div class="dpad" role="group" aria-label="D-Pad">
        <button class="btn d-up" aria-hidden="true" style="visibility:hidden;">▲</button>

        <button class="btn d-left" data-key="ArrowLeft" data-keycode="37" aria-label="Left">◀</button>
        <button class="btn d-right" data-key="ArrowRight" data-keycode="39" aria-label="Right">▶</button>
      </div>
    </div>

    <!-- Right-side actions: Enter top-right, Z/R bottom-right -->
    <div class="controls-right">
      <button id="enter-btn" class="btn enter-top" data-key="Enter" data-keycode="13" aria-label="Confirm">Enter</button>

      <div class="actions-bottom">
        <button class="btn action large jump" data-key=" " data-keycode="32" aria-label="Jump">▲</button>

        <div class="stack-up">
          <button class="btn action large up-g" data-key="ArrowUp" data-keycode="38" aria-label="Up (G)">G</button>
          <button class="btn action large" data-key="z" data-keycode="90" aria-label="Swap">Z</button>
        </div>

        <button class="btn action large" data-key="r" data-keycode="82" aria-label="Reset">R</button>
      </div>
    </div>
  </div>

  <script>
    // Initialize Ruffle from local `ruffle.js` and wire controls/fullscreen.
    function initRuffleAndControls() {
      if (!(window.RufflePlayer && typeof window.RufflePlayer.newest === 'function')) {
        console.error('Ruffle not found. Make sure `ruffle.js` is placed next to this HTML file.');
        return;
      }

      const ruffle = window.RufflePlayer.newest();
      const player = ruffle.createPlayer();
      // Ensure the player can receive focus for keyboard events from touch controls
      player.setAttribute('tabindex', '0');
      document.getElementById("game").appendChild(player);
      // Make sure the player element is focusable via script when needed
      try { player.tabIndex = 0; } catch (e) { /* ignore */ }
      
        // Mobile controls toggle behavior: keep toggle always visible and persist state
        (function () {
          const KEY = 'mobileControlsVisible';
          const toggle = document.getElementById('mobile-toggle');
          const controls = document.getElementById('mobile-controls');
          if (!toggle) return;

          function setVisible(visible) {
            if (controls) controls.style.display = visible ? '' : 'none';
            toggle.setAttribute('aria-pressed', visible ? 'true' : 'false');
            toggle.title = visible ? 'Hide mobile controls' : 'Show mobile controls';
            toggle.innerText = visible ? '✕' : '☰';
            try { localStorage.setItem(KEY, visible ? '1' : '0'); } catch (e) { /* ignore */ }
          }

          // Initialize from storage (default: visible)
          let stored = null;
          try { stored = localStorage.getItem(KEY); } catch (e) { stored = null; }
          const visible = stored === null ? true : (stored === '1');
          setVisible(visible);

          toggle.addEventListener('click', function (e) { e.preventDefault(); setVisible(toggle.getAttribute('aria-pressed') !== 'true'); });
        })();

      // Load the SWF file (must be in same folder as HTML)
      player.load("5b.swf");
      if (player && player.style) {
        player.style.width = '100%';
        player.style.height = '100%';
        player.style.display = 'block';
      }

      function toggleFullscreen(elem) {
        const doc = document;
        const isFull = doc.fullscreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;
        if (!isFull) {
          if (elem.requestFullscreen) elem.requestFullscreen();
          else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
          else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        } else {
          if (doc.exitFullscreen) doc.exitFullscreen();
          else if (doc.webkitExitFullscreen) doc.webkitExitFullscreen();
          else if (doc.msExitFullscreen) doc.msExitFullscreen();
        }
      }

      document.addEventListener('keydown', function (e) {
        const isF11 = (e.key === 'F11') || (e.keyCode === 122);
        if (isF11) {
          e.preventDefault();
          const container = document.getElementById('game') || document.documentElement;
          toggleFullscreen(container);
        }
      });

      (function () {
        const controls = document.getElementById('mobile-controls');
        if (!controls) return;

        function sendKey(type, key, keyCode, code) {
          // Try to focus the Ruffle player (or its internal canvas) so it receives keyboard events
          try {
            if (player && typeof player.focus === 'function') player.focus();
            // If the player hosts a canvas (Ruffle typically does), focus that too
            const canvas = player && player.querySelector ? player.querySelector('canvas') : null;
            if (canvas && typeof canvas.focus === 'function') canvas.focus();
          } catch (err) { /* ignore focus errors */ }

          const eventInit = { key: key, code: code || key, keyCode: keyCode, which: keyCode, bubbles: true, cancelable: true };
          let ev;
          try { ev = new KeyboardEvent(type, eventInit); }
          catch (err) { ev = document.createEvent('KeyboardEvent'); ev.initKeyboardEvent(type, true, true, window, key, 0, '', false, ''); }

          // Deliver event to the most likely target: internal canvas -> player -> window
          const canvas = player && player.querySelector ? player.querySelector('canvas') : null;
          if (canvas && typeof canvas.dispatchEvent === 'function') canvas.dispatchEvent(ev);
          else if (player && typeof player.dispatchEvent === 'function') player.dispatchEvent(ev);
          window.dispatchEvent(ev);
        }

        function bindButton(btn) {
          const key = btn.getAttribute('data-key');
          const keyCode = parseInt(btn.getAttribute('data-keycode'), 10) || 0;
          const code = btn.getAttribute('data-code') || key;
          function onPress(e) { e.preventDefault(); btn.classList.add('active'); sendKey('keydown', key, keyCode, code); }
          function onRelease(e) { e && e.preventDefault(); btn.classList.remove('active'); sendKey('keyup', key, keyCode, code); }
          // When user touches controls for the first time, ensure the player is focused
          const firstTouchHandler = function () {
            try {
              if (player && typeof player.focus === 'function') player.focus();
              const canvas = player && player.querySelector ? player.querySelector('canvas') : null;
              if (canvas && typeof canvas.focus === 'function') canvas.focus();
            } catch (err) { /* ignore */ }
            // remove this handler after first use
            btn.removeEventListener('touchstart', firstTouchHandler);
            btn.removeEventListener('mousedown', firstTouchHandler);
          };
          btn.addEventListener('touchstart', firstTouchHandler, {passive:false}); btn.addEventListener('mousedown', firstTouchHandler);

          btn.addEventListener('touchstart', onPress, {passive:false}); btn.addEventListener('mousedown', onPress);
          btn.addEventListener('touchend', onRelease); btn.addEventListener('touchcancel', onRelease); btn.addEventListener('mouseup', onRelease); btn.addEventListener('mouseleave', onRelease);
        }

        const buttons = controls.querySelectorAll('.btn');
        buttons.forEach(bindButton);
      })();
    }

    // Local script should load synchronously; initialize immediately.
    initRuffleAndControls();
  </script>

  <style>
    /* Responsive mobile controls with translucent blurred buttons */
    :root {
      --ctrl-gap: clamp(6px, 0.8vmin, 14px);
      --btn-size: clamp(40px, 6vmin, 64px); /* base button */
      --btn-large-mult: 1.35;
      --enter-width: clamp(84px, 16vmin, 160px);
      --enter-height: clamp(44px, 9vmin, 96px);
    }

    /* Toggle button in top-left to show/hide mobile controls */
    #mobile-toggle {
      position: fixed;
      top: calc(env(safe-area-inset-top, 8px));
      left: calc(env(safe-area-inset-left, 8px));
      z-index: 10001;
      width: 44px;
      height: 44px;
      border-radius: 10px;
      background: rgba(0,0,0,0.5);
      color: #fff;
      border: 2px solid rgba(255,255,255,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      pointer-events: auto;
    }

    #mobile-toggle:focus { outline: 2px solid rgba(255,255,255,0.18); }


    #mobile-controls {
      position: fixed;
      inset: auto 1rem 1rem 1rem;
      z-index: 9999;
      pointer-events: auto;
    }

    .controls-left {
      position: fixed;
      left: calc(env(safe-area-inset-left, 0px) + 1rem);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 14vh);
    }

    .controls-right {
      position: fixed;
      right: calc(env(safe-area-inset-right, 0px) + 1rem);
      top: 1rem;
      bottom: 1rem;
      pointer-events: none;
    }

    .dpad {
      display: grid;
      grid-template-areas:
        "up up up"
        "left center right";
      grid-template-columns: var(--btn-size) var(--btn-size) var(--btn-size);
      grid-auto-rows: var(--btn-size);
      gap: var(--ctrl-gap);
      align-items: center;
    }

    .d-up { grid-area: up; }
    .d-left { grid-area: left; }
    .d-center { grid-area: center; }
    .d-right { grid-area: right; }

    /* Base button style: translucent with blur */
    .btn {
      background: rgba(0, 0, 0, 0.4); /* translucent black */
      color: #fff;
      border: 2px solid rgba(255, 255, 255, 0.6);
      border-radius: calc(var(--btn-size) * 0.125);
      width: var(--btn-size);
      height: var(--btn-size);
      font-size: calc(var(--btn-size) * 0.42);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.6);
      pointer-events: auto;
      backdrop-filter: blur(6px); /* blur effect */
      -webkit-backdrop-filter: blur(6px); /* Safari support */
    }

    .btn:focus {
      outline: 2px solid rgba(255,255,255,0.18);
    }

    .btn.large {
      width: calc(var(--btn-size) * var(--btn-large-mult));
      height: calc(var(--btn-size) * var(--btn-large-mult));
      font-size: calc(var(--btn-size) * 0.56);
      border-radius: calc(var(--btn-size) * 0.14);
    }

    .enter-top {
      position: fixed;
      top: 1rem;
      right: 1rem;
      width: var(--enter-width);
      height: var(--enter-height);
      font-size: calc(var(--enter-height) * 0.45);
      border-radius: calc(var(--enter-height) * 0.14);
      pointer-events: auto;
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    .actions-bottom {
      position: fixed;
      right: calc(env(safe-area-inset-right, 0px) + 1rem);
      bottom: calc(env(safe-area-inset-bottom, 0px) + 14vh);
      display: flex;
      gap: var(--ctrl-gap);
      pointer-events: auto;
      flex-direction: row-reverse;
      align-items: flex-end;
    }

    .btn:active,
    .btn.active {
      transform: scale(0.96);
      background: rgba(255,255,255,0.12); /* lighter translucent when pressed */
    }

    .actions-bottom .action {
      transform: translateY(calc(-0.15 * var(--btn-size)));
    }

    /* Stack G above Z in a column and match sizes */
    .stack-up {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: calc(var(--ctrl-gap) * 0.4);
      pointer-events: auto;
    }
    .stack-up .up-g {
      /* reuse large action sizing so G matches Z */
      width: calc(var(--btn-size) * var(--btn-large-mult));
      height: calc(var(--btn-size) * var(--btn-large-mult));
      font-size: calc(var(--btn-size) * 0.56);
      border-radius: calc(var(--btn-size) * 0.14);
    }

    .btn.jump {
      width: calc(var(--btn-size) * var(--btn-large-mult));
      height: calc(var(--btn-size) * var(--btn-large-mult));
      font-size: calc(var(--btn-size) * 0.56);
      border-radius: calc(var(--btn-size) * 0.14);
    }

    .controls-right .btn,
    .controls-right .actions-bottom {
      pointer-events: auto;
    }

    @media (min-width: 900px) {
      :root {
        --btn-size: clamp(40px, 4.2vmin, 56px);
      }
      .enter-top {
        width: clamp(80px, 9vw, 120px);
        height: clamp(36px, 5.5vh, 56px);
      }
    }
</style>
  <script>
    // Register service worker to enable PWA offline behavior and installability.
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function () {
        navigator.serviceWorker.register('service-worker.js').then(function (reg) {
          // Successful registration
          console.log('ServiceWorker registration succeeded:', reg.scope);
        }, function (err) {
          console.warn('ServiceWorker registration failed:', err);
        });
      });
    }
  </script>
</body>
</html>

